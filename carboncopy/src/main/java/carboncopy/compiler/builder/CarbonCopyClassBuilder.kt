package carboncopy.compiler.builder

import carboncopy.annotations.CarbonCopyExclude
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.TypeSpec
import javax.lang.model.element.Element
import javax.lang.model.element.ElementKind
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement
import javax.lang.model.type.TypeKind

/**
 * Builds the CarbonCopy class
 *
 * @author js
 */
class CarbonCopyClassBuilder(private val bindingManager: BindingManager) {


    /**
     * Generate the carbon copy class
     */
    fun build() {
        val classBuilder = TypeSpec
                .classBuilder(bindingManager.copyClassName)
                .addModifiers(Modifier.PUBLIC)

        addJavaDoc(classBuilder)
        addFields(classBuilder)

        JavaFile.builder(bindingManager.packageName, classBuilder.build()).build().writeTo(bindingManager.filer)
    }

    /**
     * Add the java doc for the class
     */
    private fun addJavaDoc(classBuilder: TypeSpec.Builder) {
        classBuilder.addJavadoc("CarbonCopy of {@link ${bindingManager.packageName}.${bindingManager.originalClassName}  } \n")
        classBuilder.addJavadoc("<p>\n")
        classBuilder.addJavadoc("Auto-generated by <a href=\"https://bit.ly/CarbonCopyLibrary\">CarbonCopy</a>\n")
    }

    /**
     * Add the fields
     */
    private fun addFields(classBuilder: TypeSpec.Builder) {
        processFields({ CarbonCopyFieldBuilder(bindingManager, classBuilder, it).build() })
    }

    /**
     * Finds that elements that needs to be processed
     */
    private fun processFields(elementVisitor: (member: Element) -> Unit) {
        processFields(bindingManager.classElement, elementVisitor)
    }

    /**
     * Recursevely Visit extended elements
     */
    private fun processFields(element: Element?, elementVisitor: (member: Element) -> Unit) {
        if (element is TypeElement) {
            element.enclosedElements
                    .filter { it.kind == ElementKind.FIELD && it.getAnnotation(CarbonCopyExclude::class.java) == null }
                    .forEach { elementVisitor(it) }

            if (element.superclass.kind != TypeKind.NONE) {
                processFields(bindingManager.getElement(element.superclass.toString()), elementVisitor)
            }
        }
    }


}